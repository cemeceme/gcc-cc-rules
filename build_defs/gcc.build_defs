
def _getBuildTUCommand(c:bool):
    def _buildTUCommand(name:str):
        """
        Generates the command for a translation unit as a pre-build call.
        """
        labels = get_labels(name, "")

        # Get default flags.
        defaultFlags = []
        std = ""
        if(c):
            std = "c99" # C standard to use.
            defaultFlags += CONFIG.GCC.DEFAULT_OPT_CFLAGS.split(" ")
        else:
            std = "c++20" # C++ standard to use.
            defaultFlags += CONFIG.GCC.DEFAULT_OPT_CPPFLAGS.split(" ")

        # Parse labels.
        defines = []
        includes = []
        warnings = []
        for label in labels:
            if(not label.startswith("cc:")):
                continue # Skip labels not meant for cc rules.

            # Strip prefix.
            remaining = label[3:]

            # Add label to corresponding list.
            if(remaining.startswith("inc:")):
                includes += [remaining[4:]]

            if(remaining.startswith("def:")):
                defines += [remaining[4:]]
            
            if(remaining.startswith("cf:")):
                defaultFlags += [remaining[3:]]

        # Parse default flags.
        flags = []
        for flag in defaultFlags:
            strippedFlag = flag.lstrip("-")
            if(strippedFlag.startswith("std=")):
                std = strippedFlag[4:]
                continue

            if(strippedFlag.startswith("I")):
                include += [strippedFlag[1:]]
                continue

            if(strippedFlag.startswith("D")):
                defines += [strippedFlag[1:]]
                continue
            
            if(strippedFlag.startswith("W")):
                warnings += [strippedFlag[1:]]
                continue

            flags += [flag]


        # Set up command.
        cmd = ["\"$TOOLS_CC\"", "-c", "-o", "\"$OUT\""] # Gcc in compile only mode. TODO is "-s" needed?

        # Include paths.
        cmd += ["-I."] 
        for include in includes:
            # cmd += ["-I" + include]
            cmd += ["-isystem" + include] # TODO figure out how to dynamically select if isystem or I should be used (I.E if this is a subrepo, use isystem)

        # Defines.
        for define in defines:
            cmd += ["-D" + define]

        # Source files.
        cmd += ["${SRCS_SRCS}"]

        # Standard. 
        cmd += ["--std=" + std]

        # Error/warning flags.
        for warning in warnings:
            cmd += ["-W" + warning]

        # Other flags.
        cmd += flags
        cmd += ["-fPIC"] # Position independent code.
        # cmd += ["-isystem", "."] # System Include paths.

        set_command(name, "opt", " ".join(cmd))
    return(_buildTUCommand)

def _getBuildLinkCommand(sharedLib:bool):
    def _buildLinkCommand(name:str):
        """
        Generates the command for a link step as a pre-build call.
        """

        labels = get_labels(name, "")

        includes = []
        libraries = []
        flags = []
        alwaysLink = []
        for label in labels:
            if(not label.startswith("cc:")):
                continue # Skip labels not meant for cc rules.

            # Strip prefix.
            remaining = label[3:]

            # Add label to corresponding list.
            if(remaining.startswith("inc:")):
                includes += [remaining[4:]]
            
            if(remaining.startswith("lib:")):
                libraries += [remaining[4:]]
            
            if(remaining.startswith("ld:")):
                flags += [remaining[3:].replace(" ", ",")]

            if(remaining.startswith("al:")):
                alwaysLink += [remaining[3:]]

        # Objects/archives to link.
        # It may also be interesting to actually recognize the objects to link, which would allow for deduplication with alwaysLink options.
        linkObjects = ["`find . -name \"*.o\" -or -name \"*.a\" | sort`"]
        alwaysLinkObjects = alwaysLink

        cmd = ["$TOOLS_LD", "-o", "\"$OUT\""]
        if(sharedLib):
            # Always link all inputs for shared libraries.
            alwaysLinkObjects = linkObjects
            linkObjects = []
            cmd += ["--shared"]
        
        # Add always link objects if any.
        if(len(alwaysLinkObjects) > 0):
            cmd += ["-Wl,--whole-archive"] + alwaysLinkObjects + ["-Wl,--no-whole-archive"]
        
        # Add normal link objects, if any.
        if(len(linkObjects) > 0):
            cmd += ["-Wl,--start-group"] + linkObjects + ["-Wl,--end-group"]
            

        # Add library paths.
        includeCmd = []
        for library in libraries:
            directory, fileName = split_path(library)
            includeCmd += ["-L" + directory, "-l" + fileName]

        if(len(includeCmd) > 0):
            cmd += [",".join(["-Wl"] + includeCmd)] # Include paths.

        cmd += ["-Wl,--build-id=none"] # Disable build ID.

        # Linker flags.
        if(len(flags) > 0):
            cmd += [",".join(["-Wl"] + flags)]

        cmd += ["-lpthread", "-fPIC", "-O3", "-fmax-errors=5"] # Optimizations, thread support and max errors.

        set_command(name, "opt", " ".join(cmd))

    return(_buildLinkCommand)

def getTranslationUnit(c:bool):

    # Tool definitions.
    tools = {}

    # Select correct tool depending on if this is for C or C++
    if(c):
        tools["cc"] = CONFIG.GCC.CC_TOOL
    else:
        tools["cc"] = CONFIG.GCC.CPP_TOOL

    def translationUnit(name:str, src:str, out:str=None, hdrs:list=[], deps:list=[], labels:list=[]):

        srcRule = build_rule(
            name=name,
            outs=[out],
            optional_outs=['*.gcno'],
            deps=deps,
            srcs={'srcs': [src], 'hdrs': hdrs},
            cmd="",
            pre_build=_getBuildTUCommand(c),
            building_description='Compiling... ',
            binary=False,
            needs_transitive_deps=True,
            requires=["cc_hdrs", "test"],
            labels=labels,
            tools=tools
        )
        return(srcRule)
    return(translationUnit)

def archive(name: str, out:str, srcs:list, deps:list):

    # Tool definitions.
    tools = {
        "ar": [CONFIG.GCC.AR_TOOL],
    }

    archiveRule = build_rule(
        name=name,
        outs=[out],
        srcs=srcs,
        cmd="\"$TOOLS_AR\" rcs \"$OUT\" `find . -name \"*.o\" | sort`",
        building_description='Archiving...',
        binary=True,
        deps=deps,
        tools = tools,
        output_is_complete=False
    )

    return(archiveRule)

def link(name:str, out:str, deps:list=[], sharedLib:bool, labels:list=[]):
    pass

    # Tool definitions.
    tools = {
        "ld": [CONFIG.GCC.LD_TOOL]
    }

    requires = ["cc", "test"]

    linkRule = build_rule(
        name=name,
        outs=[out],
        optional_outs=['*.gcno'],
        deps=deps,
        cmd="",
        pre_build=_getBuildLinkCommand(sharedLib=sharedLib),
        building_description='Linking... ',
        binary=True,
        needs_transitive_deps=True,
        output_is_complete=True,
        requires=requires,
        labels=labels,
        tools=tools,
    )
    return(linkRule)